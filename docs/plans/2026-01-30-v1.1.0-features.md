# v1.1.0 Features Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** å®ç°æš—è‰²æ¨¡å¼ã€Markdown å¯¼å‡ºã€å…¨å±€æœç´¢å’Œå¼€æœºè‡ªå¯åŠŸèƒ½

**Architecture:**
- æš—è‰²æ¨¡å¼é€šè¿‡ Ant Design ConfigProvider çš„ algorithm å®ç°
- å¯¼å‡ºåŠŸèƒ½åœ¨ä¸»è¿›ç¨‹å®ç°æ–‡ä»¶å†™å…¥ï¼Œæ¸²æŸ“è¿›ç¨‹æä¾› UI
- å…¨å±€æœç´¢åœ¨ HistoryViewer ç»„ä»¶ä¸­å®ç°ï¼Œæ”¯æŒè·¨ä¼šè¯æœç´¢å’Œå…³é”®è¯é«˜äº®
- å¼€æœºè‡ªå¯ä½¿ç”¨ Electron çš„ app.setLoginItemSettings API

**Tech Stack:**
- Electron 28
- React 18 + TypeScript
- Ant Design 6.2.2
- highlight-words (å…³é”®è¯é«˜äº®)

---

## Task 1: æš—è‰²æ¨¡å¼åˆ‡æ¢

**Files:**
- Modify: `src/App.tsx`
- Modify: `src/theme.ts`
- Modify: `src/types.ts`
- Modify: `electron/main.ts`
- Modify: `electron/preload.ts`

**Step 1: æ‰©å±•ç±»å‹å®šä¹‰ä»¥æ”¯æŒä¸»é¢˜è®¾ç½®**

åœ¨ `src/types.ts` æ·»åŠ ï¼š

```typescript
export interface AppSettings {
  darkMode: boolean
  autoStart: boolean
}

export interface ElectronAPI {
  // ... ç°æœ‰æ–¹æ³•
  getAppSettings: () => Promise<AppSettings>
  saveAppSettings: (settings: AppSettings) => Promise<{ success: boolean; error?: string }>
}
```

**Step 2: æ·»åŠ æš—è‰²ä¸»é¢˜é…ç½®**

åœ¨ `src/theme.ts` æ·»åŠ ï¼š

```typescript
import { theme as antdTheme } from 'antd'

export const lightTheme: ThemeConfig = {
  // ç°æœ‰çš„ theme é…ç½®
}

export const darkTheme: ThemeConfig = {
  algorithm: antdTheme.darkAlgorithm,
  token: {
    ...lightTheme.token,
  },
  components: {
    ...lightTheme.components,
  },
}
```

**Step 3: åœ¨ä¸»è¿›ç¨‹æ·»åŠ è®¾ç½®å­˜å‚¨**

åœ¨ `electron/main.ts` æ·»åŠ ï¼š

```typescript
// è·å–åº”ç”¨è®¾ç½®
ipcMain.handle('get-app-settings', async () => {
  const darkMode = store.get('darkMode', false) as boolean
  const autoStart = store.get('autoStart', false) as boolean
  return { darkMode, autoStart }
})

// ä¿å­˜åº”ç”¨è®¾ç½®
ipcMain.handle('save-app-settings', async (_, settings: { darkMode: boolean; autoStart: boolean }) => {
  try {
    store.set('darkMode', settings.darkMode)
    store.set('autoStart', settings.autoStart)

    // è®¾ç½®å¼€æœºè‡ªå¯
    app.setLoginItemSettings({
      openAtLogin: settings.autoStart,
      openAsHidden: false
    })

    return { success: true }
  } catch (error) {
    return { success: false, error: (error as Error).message }
  }
})
```

**Step 4: åœ¨ preload ä¸­æš´éœ² API**

åœ¨ `electron/preload.ts` æ·»åŠ ï¼š

```typescript
getAppSettings: () => ipcRenderer.invoke('get-app-settings'),
saveAppSettings: (settings: { darkMode: boolean; autoStart: boolean }) =>
  ipcRenderer.invoke('save-app-settings', settings),
```

**Step 5: åœ¨ App ç»„ä»¶ä¸­å®ç°ä¸»é¢˜åˆ‡æ¢**

åœ¨ `src/App.tsx` æ·»åŠ çŠ¶æ€å’Œåˆ‡æ¢é€»è¾‘ï¼š

```typescript
import { lightTheme, darkTheme } from './theme'

const [darkMode, setDarkMode] = useState(false)

useEffect(() => {
  window.electronAPI.getAppSettings().then(settings => {
    setDarkMode(settings.darkMode)
  })
}, [])

const handleThemeToggle = async () => {
  const newDarkMode = !darkMode
  setDarkMode(newDarkMode)
  await window.electronAPI.saveAppSettings({ darkMode: newDarkMode, autoStart: false })
}

// åœ¨ ConfigProvider ä¸­ä½¿ç”¨
<ConfigProvider theme={darkMode ? darkTheme : lightTheme}>
```

**Step 6: åœ¨ StatusBar æ·»åŠ ä¸»é¢˜åˆ‡æ¢æŒ‰é’®**

ä¿®æ”¹ `src/components/StatusBar.tsx`ï¼Œæ·»åŠ ï¼š

```typescript
import { BulbOutlined } from '@ant-design/icons'

interface StatusBarProps {
  claudeDir: string
  darkMode: boolean
  onThemeToggle: () => void
}

// åœ¨çŠ¶æ€æ å³ä¾§æ·»åŠ åˆ‡æ¢æŒ‰é’®
<Button
  type="text"
  icon={<BulbOutlined />}
  onClick={onThemeToggle}
  style={{ color: '#fff' }}
>
  {darkMode ? 'æµ…è‰²' : 'æ·±è‰²'}
</Button>
```

**Step 7: æµ‹è¯•æš—è‰²æ¨¡å¼**

å¯åŠ¨åº”ç”¨ï¼Œç‚¹å‡»ä¸»é¢˜åˆ‡æ¢æŒ‰é’®ï¼ŒéªŒè¯ï¼š
- ä¸»é¢˜èƒ½å¤Ÿæ­£å¸¸åˆ‡æ¢
- è®¾ç½®èƒ½å¤ŸæŒä¹…åŒ–
- é‡å¯åº”ç”¨åä¿æŒè®¾ç½®

**Step 8: æäº¤ä»£ç **

```bash
git add src/App.tsx src/theme.ts src/types.ts src/components/StatusBar.tsx electron/main.ts electron/preload.ts
git commit -m "feat: add dark mode toggle"
```

---

## Task 2: å¼€æœºè‡ªå¯åŠ¨è®¾ç½®

**Files:**
- Create: `src/components/SettingsModal.tsx`
- Modify: `src/App.tsx`
- Modify: `src/components/StatusBar.tsx`

**Step 1: åˆ›å»ºè®¾ç½®å¼¹çª—ç»„ä»¶**

åˆ›å»º `src/components/SettingsModal.tsx`ï¼š

```typescript
import { Modal, Switch, Space, Typography } from 'antd'
import { useState, useEffect } from 'react'

const { Text } = Typography

interface SettingsModalProps {
  visible: boolean
  onClose: () => void
}

function SettingsModal({ visible, onClose }: SettingsModalProps) {
  const [darkMode, setDarkMode] = useState(false)
  const [autoStart, setAutoStart] = useState(false)

  useEffect(() => {
    if (visible) {
      window.electronAPI.getAppSettings().then(settings => {
        setDarkMode(settings.darkMode)
        setAutoStart(settings.autoStart)
      })
    }
  }, [visible])

  const handleSave = async () => {
    await window.electronAPI.saveAppSettings({ darkMode, autoStart })
    onClose()
  }

  return (
    <Modal
      title="è®¾ç½®"
      open={visible}
      onOk={handleSave}
      onCancel={onClose}
      okText="ä¿å­˜"
      cancelText="å–æ¶ˆ"
    >
      <Space direction="vertical" size="large" style={{ width: '100%' }}>
        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
          <Text>æ·±è‰²æ¨¡å¼</Text>
          <Switch checked={darkMode} onChange={setDarkMode} />
        </div>
        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
          <Text>å¼€æœºè‡ªå¯åŠ¨</Text>
          <Switch checked={autoStart} onChange={setAutoStart} />
        </div>
      </Space>
    </Modal>
  )
}

export default SettingsModal
```

**Step 2: åœ¨ StatusBar æ·»åŠ è®¾ç½®æŒ‰é’®**

ä¿®æ”¹ `src/components/StatusBar.tsx`ï¼š

```typescript
import { SettingOutlined } from '@ant-design/icons'

interface StatusBarProps {
  claudeDir: string
  onOpenSettings: () => void
}

// æ·»åŠ è®¾ç½®æŒ‰é’®
<Button
  type="text"
  icon={<SettingOutlined />}
  onClick={onOpenSettings}
  style={{ color: '#fff' }}
>
  è®¾ç½®
</Button>
```

**Step 3: åœ¨ App ä¸­é›†æˆè®¾ç½®å¼¹çª—**

ä¿®æ”¹ `src/App.tsx`ï¼š

```typescript
import SettingsModal from './components/SettingsModal'

const [settingsVisible, setSettingsVisible] = useState(false)

<SettingsModal
  visible={settingsVisible}
  onClose={() => setSettingsVisible(false)}
/>

<StatusBar
  claudeDir={claudeDir}
  onOpenSettings={() => setSettingsVisible(true)}
/>
```

**Step 4: æµ‹è¯•å¼€æœºè‡ªå¯**

- æ‰“å¼€è®¾ç½®ï¼Œå¯ç”¨å¼€æœºè‡ªå¯
- é‡å¯ç³»ç»Ÿ
- éªŒè¯åº”ç”¨è‡ªåŠ¨å¯åŠ¨

**Step 5: æäº¤ä»£ç **

```bash
git add src/components/SettingsModal.tsx src/App.tsx src/components/StatusBar.tsx
git commit -m "feat: add auto-start setting"
```

---

## Task 3: Markdown å¯¼å‡ºåŠŸèƒ½

**Files:**
- Modify: `electron/main.ts`
- Modify: `electron/preload.ts`
- Modify: `src/types.ts`
- Modify: `src/components/HistoryViewer.tsx`

**Step 1: æ‰©å±•ç±»å‹å®šä¹‰**

åœ¨ `src/types.ts` æ·»åŠ ï¼š

```typescript
export interface ExportOptions {
  format: 'markdown' | 'csv'
  sessionIds?: string[]
  startDate?: number
  endDate?: number
}

export interface ElectronAPI {
  // ... ç°æœ‰æ–¹æ³•
  exportRecords: (options: ExportOptions) => Promise<{ success: boolean; filePath?: string; error?: string }>
}
```

**Step 2: åœ¨ä¸»è¿›ç¨‹å®ç° Markdown å¯¼å‡º**

åœ¨ `electron/main.ts` æ·»åŠ ï¼š

```typescript
import { dialog } from 'electron'

ipcMain.handle('export-records', async (_, options: ExportOptions) => {
  try {
    const savePath = store.get('savePath', '') as string
    if (!savePath) {
      return { success: false, error: 'æœªé…ç½®ä¿å­˜è·¯å¾„' }
    }

    // è¯»å–è®°å½•
    const files = fs.readdirSync(savePath).filter(f => f.endsWith('.jsonl'))
    let allRecords: any[] = []

    for (const file of files) {
      const filePath = path.join(savePath, file)
      const content = fs.readFileSync(filePath, 'utf-8')
      const lines = content.split('\n').filter(line => line.trim())

      for (const line of lines) {
        try {
          const record = JSON.parse(line)
          const timestamp = new Date(record.timestamp).getTime()

          // è¿‡æ»¤æ¡ä»¶
          if (options.startDate && timestamp < options.startDate) continue
          if (options.endDate && timestamp > options.endDate) continue
          if (options.sessionIds && options.sessionIds.length > 0) {
            if (!options.sessionIds.includes(record.sessionId || '')) continue
          }

          allRecords.push({
            timestamp,
            project: record.project,
            sessionId: record.sessionId || '',
            display: record.prompt || '',
            pastedContents: record.pastedContents || {}
          })
        } catch (e) {
          console.error('è§£æè®°å½•å¤±è´¥:', e)
        }
      }
    }

    // æŒ‰æ—¶é—´æ’åº
    allRecords.sort((a, b) => b.timestamp - a.timestamp)

    // ç”Ÿæˆ Markdown
    let markdown = '# Claude Code å¯¹è¯è®°å½•\n\n'
    markdown += `å¯¼å‡ºæ—¶é—´: ${new Date().toLocaleString('zh-CN')}\n\n`
    markdown += `è®°å½•æ€»æ•°: ${allRecords.length}\n\n`
    markdown += '---\n\n'

    // æŒ‰ä¼šè¯åˆ†ç»„
    const sessions = new Map<string, typeof allRecords>()
    allRecords.forEach(record => {
      const key = record.sessionId || `single-${record.timestamp}`
      if (!sessions.has(key)) {
        sessions.set(key, [])
      }
      sessions.get(key)!.push(record)
    })

    sessions.forEach((records, sessionId) => {
      const firstRecord = records[0]
      const projectName = path.basename(firstRecord.project)

      markdown += `## ${projectName}\n\n`
      markdown += `**Session ID:** \`${sessionId}\`\n\n`
      markdown += `**é¡¹ç›®è·¯å¾„:** \`${firstRecord.project}\`\n\n`
      markdown += `**å¯¹è¯æ•°é‡:** ${records.length}\n\n`

      records.forEach((record, index) => {
        markdown += `### å¯¹è¯ ${index + 1}\n\n`
        markdown += `**æ—¶é—´:** ${new Date(record.timestamp).toLocaleString('zh-CN')}\n\n`
        markdown += `**å†…å®¹:**\n\n`
        markdown += `\`\`\`\n${record.display}\n\`\`\`\n\n`

        if (record.pastedContents && Object.keys(record.pastedContents).length > 0) {
          markdown += `**é™„ä»¶:** ${Object.keys(record.pastedContents).length} ä¸ª\n\n`
        }

        markdown += '---\n\n'
      })
    })

    // ä¿å­˜æ–‡ä»¶
    const defaultPath = path.join(
      require('os').homedir(),
      'Desktop',
      `claude-records-${new Date().toISOString().split('T')[0]}.md`
    )

    const result = await dialog.showSaveDialog({
      title: 'å¯¼å‡º Markdown',
      defaultPath,
      filters: [
        { name: 'Markdown', extensions: ['md'] },
        { name: 'All Files', extensions: ['*'] }
      ]
    })

    if (result.canceled) {
      return { success: false, error: 'ç”¨æˆ·å–æ¶ˆ' }
    }

    fs.writeFileSync(result.filePath!, markdown, 'utf-8')
    return { success: true, filePath: result.filePath }
  } catch (error) {
    console.error('å¯¼å‡ºå¤±è´¥:', error)
    return { success: false, error: (error as Error).message }
  }
})
```

**Step 3: åœ¨ preload ä¸­æš´éœ² API**

åœ¨ `electron/preload.ts` æ·»åŠ ï¼š

```typescript
exportRecords: (options: ExportOptions) => ipcRenderer.invoke('export-records', options),
```

**Step 4: åœ¨ HistoryViewer æ·»åŠ å¯¼å‡ºæŒ‰é’®**

ä¿®æ”¹ `src/components/HistoryViewer.tsx`ï¼š

```typescript
import { ExportOutlined } from '@ant-design/icons'

const handleExport = async () => {
  const result = await window.electronAPI.exportRecords({
    format: 'markdown'
  })

  if (result.success) {
    message.success(`å¯¼å‡ºæˆåŠŸ: ${result.filePath}`)
  } else {
    message.error(`å¯¼å‡ºå¤±è´¥: ${result.error}`)
  }
}

// åœ¨é¡¶éƒ¨å·¥å…·æ æ·»åŠ å¯¼å‡ºæŒ‰é’®
<Button
  icon={<ExportOutlined />}
  onClick={handleExport}
  size="small"
>
  å¯¼å‡º Markdown
</Button>
```

**Step 5: æ·»åŠ é«˜çº§å¯¼å‡ºé€‰é¡¹**

åˆ›å»ºå¯¼å‡ºå¯¹è¯æ¡†ï¼Œæ”¯æŒé€‰æ‹©ï¼š
- å¯¼å‡ºå…¨éƒ¨ / å½“å‰ç­›é€‰ç»“æœ
- é€‰æ‹©æ—¶é—´èŒƒå›´
- é€‰æ‹©ç‰¹å®šä¼šè¯

**Step 6: æµ‹è¯•å¯¼å‡ºåŠŸèƒ½**

- å¯¼å‡ºå…¨éƒ¨è®°å½•
- å¯¼å‡ºç‰¹å®šæ—¶é—´èŒƒå›´
- éªŒè¯ Markdown æ ¼å¼æ­£ç¡®
- éªŒè¯æ–‡ä»¶å¯ä»¥æ­£å¸¸ä¿å­˜

**Step 7: æäº¤ä»£ç **

```bash
git add electron/main.ts electron/preload.ts src/types.ts src/components/HistoryViewer.tsx
git commit -m "feat: add markdown export"
```

---

## Task 4: å…¨å±€æœç´¢åŠŸèƒ½

**Files:**
- Modify: `src/components/HistoryViewer.tsx`
- Add dependency: `npm install react-highlight-words @types/react-highlight-words`

**Step 1: å®‰è£…ä¾èµ–**

```bash
npm install react-highlight-words @types/react-highlight-words
```

**Step 2: åœ¨ HistoryViewer æ·»åŠ æœç´¢çŠ¶æ€**

ä¿®æ”¹ `src/components/HistoryViewer.tsx`ï¼š

```typescript
import { SearchOutlined } from '@ant-design/icons'
import { Input } from 'antd'
import Highlighter from 'react-highlight-words'

const [searchKeyword, setSearchKeyword] = useState('')
```

**Step 3: å®ç°æœç´¢è¿‡æ»¤é€»è¾‘**

```typescript
// åœ¨ç°æœ‰çš„ filteredRecords åŸºç¡€ä¸Šæ·»åŠ æœç´¢è¿‡æ»¤
const searchedRecords = useMemo(() => {
  if (!searchKeyword.trim()) {
    return filteredRecords
  }

  const keyword = searchKeyword.toLowerCase()
  return filteredRecords.filter(record => {
    return record.display.toLowerCase().includes(keyword) ||
           record.project.toLowerCase().includes(keyword)
  })
}, [filteredRecords, searchKeyword])

// æ›´æ–° groupedRecords ä½¿ç”¨ searchedRecords
const groupedRecords = useMemo(() => {
  const groups = new Map<string, GroupedRecord>()

  searchedRecords.forEach(record => {
    // ... ç°æœ‰åˆ†ç»„é€»è¾‘
  })

  return Array.from(groups.values()).sort((a, b) => b.latestTimestamp - a.latestTimestamp)
}, [searchedRecords])
```

**Step 4: æ·»åŠ æœç´¢æ¡† UI**

```typescript
// åœ¨æ—¶é—´ç­›é€‰å™¨ä¸‹æ–¹æ·»åŠ æœç´¢æ¡†
<Card size="small" bodyStyle={{ padding: 12 }}>
  <Input
    placeholder="æœç´¢å¯¹è¯å†…å®¹ã€é¡¹ç›®åç§°..."
    prefix={<SearchOutlined />}
    value={searchKeyword}
    onChange={(e) => setSearchKeyword(e.target.value)}
    allowClear
  />
</Card>
```

**Step 5: å®ç°å…³é”®è¯é«˜äº®**

ä¿®æ”¹ renderContent å‡½æ•°ï¼Œæ·»åŠ é«˜äº®æ”¯æŒï¼š

```typescript
const renderContentWithHighlight = (content: string) => {
  const rendered = renderContent(content)

  if (!searchKeyword.trim()) {
    return rendered
  }

  // å¯¹äºçº¯æ–‡æœ¬å†…å®¹ï¼Œä½¿ç”¨ Highlighter
  if (typeof rendered === 'string' || !searchKeyword) {
    return (
      <Highlighter
        searchWords={[searchKeyword]}
        autoEscape
        textToHighlight={content}
        highlightStyle={{
          backgroundColor: '#ffc069',
          padding: 0,
        }}
      />
    )
  }

  return rendered
}
```

**Step 6: æ·»åŠ æœç´¢ç»“æœç»Ÿè®¡**

```typescript
<Text type="secondary" style={{ fontSize: 12 }}>
  å…± {groupedRecords.length} ä¸ªä¼šè¯ï¼Œ{searchedRecords.length} æ¡è®°å½•
  {searchKeyword && ` (æœç´¢"${searchKeyword}")`}
</Text>
```

**Step 7: æµ‹è¯•æœç´¢åŠŸèƒ½**

- è¾“å…¥å…³é”®è¯æœç´¢
- éªŒè¯æœç´¢ç»“æœæ­£ç¡®
- éªŒè¯å…³é”®è¯é«˜äº®
- éªŒè¯æ¸…ç©ºæœç´¢åŠŸèƒ½

**Step 8: æäº¤ä»£ç **

```bash
git add src/components/HistoryViewer.tsx package.json package-lock.json
git commit -m "feat: add global search with keyword highlighting"
```

---

## Task 5: æ€§èƒ½ä¼˜åŒ–å’Œæµ‹è¯•

**Step 1: æ·»åŠ è™šæ‹Ÿæ»šåŠ¨ï¼ˆå¯é€‰ï¼Œå¦‚æœæ•°æ®é‡å¤§ï¼‰**

å¦‚æœä¼šè¯æ•°é‡è¶…è¿‡ 100 ä¸ªï¼Œè€ƒè™‘ä½¿ç”¨ `rc-virtual-list`ï¼š

```bash
npm install rc-virtual-list
```

**Step 2: æ·»åŠ æœç´¢é˜²æŠ–**

```typescript
import { debounce } from 'lodash'

const debouncedSearch = useMemo(
  () => debounce((value: string) => {
    setSearchKeyword(value)
  }, 300),
  []
)
```

**Step 3: å…¨é¢æµ‹è¯•**

æµ‹è¯•æ¸…å•ï¼š
- [ ] æš—è‰²æ¨¡å¼åˆ‡æ¢æ­£å¸¸
- [ ] æš—è‰²æ¨¡å¼è®¾ç½®æŒä¹…åŒ–
- [ ] å¼€æœºè‡ªå¯åŠ¨åŠŸèƒ½æ­£å¸¸
- [ ] å¯¼å‡º Markdown æ ¼å¼æ­£ç¡®
- [ ] å¯¼å‡ºæ–‡ä»¶åŒ…å«æ‰€æœ‰å¿…è¦ä¿¡æ¯
- [ ] å…¨å±€æœç´¢ç»“æœå‡†ç¡®
- [ ] å…³é”®è¯é«˜äº®æ˜¾ç¤ºæ­£ç¡®
- [ ] å¤§é‡æ•°æ®æ—¶æ€§èƒ½è‰¯å¥½
- [ ] æ‰€æœ‰åŠŸèƒ½åœ¨æš—è‰²æ¨¡å¼ä¸‹æ˜¾ç¤ºæ­£å¸¸

**Step 4: æ›´æ–° README**

åœ¨ README.md æ·»åŠ æ–°åŠŸèƒ½è¯´æ˜ï¼š

```markdown
## æ–°åŠŸèƒ½ (v1.1.0)

- ğŸŒ™ æš—è‰²æ¨¡å¼åˆ‡æ¢
- ğŸ“¤ å¯¼å‡ºä¸º Markdown æ ¼å¼
- ğŸ” å…¨å±€æœç´¢ï¼ˆè·¨ä¼šè¯ï¼‰
- ğŸš€ å¼€æœºè‡ªå¯åŠ¨è®¾ç½®
```

**Step 5: æœ€ç»ˆæäº¤**

```bash
git add README.md
git commit -m "docs: update README for v1.1.0"
```

---

## å®Œæˆå

1. æµ‹è¯•æ‰€æœ‰åŠŸèƒ½
2. åˆ›å»º Pull Request
3. åˆå¹¶åˆ° main åˆ†æ”¯
4. æ‰“ v1.1.0 tag
5. æ„å»ºå‘å¸ƒåŒ…
